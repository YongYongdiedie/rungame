<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Mobile Wireframe Runner</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  body { margin:0; overflow:hidden; background:black; touch-action:none; }
  #overlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    color: white;
    font-family: sans-serif;
    font-size: 28px;
    background: rgba(0,0,0,0.6);
    z-index: 10;
  }
</style>
</head>
<body>

<div id="overlay">
  <div>GAME OVER</div>
  <div style="font-size:16px;margin-top:10px;">TAP TO RESTART</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
/* ===== 기본 세팅 ===== */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75, window.innerWidth / window.innerHeight, 0.1, 1000
);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000);
document.body.appendChild(renderer.domElement);

/* ===== wireframe ===== */
const mat = new THREE.MeshBasicMaterial({
  color: 0xffffff,
  wireframe: true
});

/* ===== 플레이어 ===== */
const player = new THREE.Mesh(
  new THREE.BoxGeometry(1, 2, 1),
  mat
);
player.position.set(0, 1, 0);
scene.add(player);

/* ===== 바닥 ===== */
const ground = new THREE.Mesh(
  new THREE.BoxGeometry(10, 0.1, 300),
  mat
);
ground.position.z = -150;
scene.add(ground);

/* ===== 장애물 ===== */
const obstacles = [];
function createObstacle(z) {
  const o = new THREE.Mesh(
    new THREE.BoxGeometry(1, 2, 1),
    mat
  );
  o.position.set((Math.random() - 0.5) * 6, 1, z);
  scene.add(o);
  obstacles.push(o);
}
for (let i = 0; i < 12; i++) createObstacle(-30 - i * 25);

/* ===== 카메라 ===== */
camera.position.set(0, 4, 8);
camera.lookAt(player.position);

/* ===== 물리 ===== */
let velocityY = 0;
let isJumping = false;
const gravity = -0.03;
const jumpPower = 0.7;

/* ===== 상태 ===== */
let isGameOver = false;
const overlay = document.getElementById("overlay");

/* ===== 터치 입력 ===== */
let touchStartX = 0;
let touchMoved = false;

window.addEventListener("touchstart", e => {
  if (isGameOver) {
    restartGame();
    return;
  }
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchMoved = false;
});

window.addEventListener("touchmove", e => {
  if (isGameOver) return;
  const t = e.touches[0];
  const dx = t.clientX - touchStartX;

  if (Math.abs(dx) > 10) {
    touchMoved = true;
    /* ✅ 민감도 30% 증가 */
    player.position.x += dx * 0.005;
    player.position.x = Math.max(-4, Math.min(4, player.position.x));
    touchStartX = t.clientX;
  }
});

window.addEventListener("touchend", () => {
  if (isGameOver) return;
  if (!touchMoved && !isJumping) {
    velocityY = jumpPower;
    isJumping = true;
  }
});

/* ===== 충돌 판정 ===== */
function checkCollision(a, b) {
  return (
    Math.abs(a.position.x - b.position.x) < 1 &&
    Math.abs(a.position.y - b.position.y) < 2 &&
    Math.abs(a.position.z - b.position.z) < 1
  );
}

/* ===== 게임 오버 ===== */
function gameOver() {
  isGameOver = true;
  overlay.style.display = "flex";
}

/* ===== 재시작 ===== */
function restartGame() {
  isGameOver = false;
  overlay.style.display = "none";

  player.position.set(0, 1, 0);
  velocityY = 0;
  isJumping = false;

  obstacles.forEach((o, i) => {
    o.position.set(
      (Math.random() - 0.5) * 6,
      1,
      -30 - i * 25
    );
  });
}

/* ===== 애니메이션 ===== */
function animate() {
  requestAnimationFrame(animate);
  if (isGameOver) return;

  /* 점프 */
  velocityY += gravity;
  player.position.y += velocityY;
  if (player.position.y <= 1) {
    player.position.y = 1;
    velocityY = 0;
    isJumping = false;
  }

  /* 장애물 */
  obstacles.forEach(o => {
    o.position.z += 0.6;
    if (o.position.z > 10) {
      o.position.z = -300;
      o.position.x = (Math.random() - 0.5) * 6;
    }
    if (checkCollision(player, o)) gameOver();
  });

  /* 카메라 */
  camera.position.x += (player.position.x - camera.position.x) * 0.1;
  camera.lookAt(player.position);

  renderer.render(scene, camera);
}
animate();

/* ===== 리사이즈 ===== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
